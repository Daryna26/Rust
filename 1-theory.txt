1. Rust supports multithreading and can be both synchronous and asynchronous. Asynchrony is implemented using async/await and executors.

2. Rust has minimal runtime overhead for things like panic stack handling. Rust does not use GC — memory is managed using ownership and RAII.

3. Static typing means that the type of a variable is determined at compile time. Advantages: fewer runtime errors, better IDE support, and performance optimization.

4. Immutability means that the value of a variable cannot be changed after it is created. Advantages: fewer errors, easier to understand code, and safer threading.

5. Move semantics transfers ownership of data, while borrows allow temporary access without transferring ownership. Advantage: safe memory management without GC and prevention of data conflicts.

6. Traits define the general behavior that types can implement. Similar to interfaces, but allow polymorphism and generic programming.

7. Scopes indicate how long references are valid. They prevent dangling references and memory issues at compile time.

8. Macros are code that generates code, allowing you to avoid repetitive patterns. They reduce the amount of code written by hand and increase flexibility.

9. &String is a reference to a String object, &str is a reference to a string fragment. Thick pointers store the address + length (&str, &[u8]), thin pointers store only the address (&String, &Vec).

10. Static dispatch in Rust means the compiler knows the exact type and method implementations at compile time (via generics/impl Trait), allowing direct calls with no runtime overhead. Dynamic dispatch defers choosing the concrete implementation until runtime (using trait objects like &dyn Trait or Box<dyn Trait>), which adds some overhead but lets you work with types not known at compile time.
Для pull request
